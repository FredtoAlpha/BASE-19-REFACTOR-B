<script>
/**
 * ═══════════════════════════════════════════════════════════════
 * MODULE UX HARMONIE - Experience enseignant en reunion
 * ═══════════════════════════════════════════════════════════════
 *
 * R1  - Bouton Swap permanent dans le header
 * R2  - Jauge d'Harmonie toujours visible
 * R4  - Messages d'erreur humanises
 * R5  - Preview What-If avant swap
 * R6  - Mode Reunion
 * R10 - Tooltips contextuels sur badges
 */
(function() {
  'use strict';

  if (typeof document === 'undefined') return;

  // ═══════════════════════════════════════════════════
  // R2 - JAUGE D'HARMONIE
  // ═══════════════════════════════════════════════════

  /**
   * Calcule le score d'harmonie global (0-100) base sur l'equilibre des classes.
   * @returns {{ score: number, parite: number, scores: number, lv2: number, contraintes: number }}
   */
  function computeHarmonieScore() {
    if (typeof STATE === 'undefined' || !STATE.students || !STATE.rules) {
      return { score: 0, parite: 0, scores: 0, lv2: 0, contraintes: 100 };
    }

    const classes = {};
    // Collecter les eleves par classe depuis le DOM
    document.querySelectorAll('.droppable-zone').forEach(zone => {
      const className = zone.dataset.classe;
      if (!className) return;
      const students = [];
      zone.querySelectorAll('.student-card').forEach(card => {
        const id = card.dataset.id;
        if (id && STATE.students[id]) students.push(STATE.students[id]);
      });
      if (students.length > 0) classes[className] = students;
    });

    const classNames = Object.keys(classes);
    if (classNames.length < 2) return { score: 0, parite: 0, scores: 0, lv2: 0, contraintes: 100 };

    // -- Parite F/M (0-100) --
    const pariteRatios = classNames.map(cn => {
      const s = classes[cn];
      const f = s.filter(e => e.sexe === 'F').length;
      return s.length > 0 ? f / s.length : 0.5;
    });
    const avgRatio = pariteRatios.reduce((a, b) => a + b, 0) / pariteRatios.length;
    const pariteVariance = pariteRatios.reduce((sum, r) => sum + Math.pow(r - avgRatio, 2), 0) / pariteRatios.length;
    // Max variance = 0.25 (100% F vs 100% M). Score = 100 when variance = 0
    const pariteScore = Math.max(0, Math.round(100 * (1 - pariteVariance / 0.05)));

    // -- Scores COM (0-100) --
    const comAverages = classNames.map(cn => {
      const s = classes[cn];
      const withCom = s.filter(e => e.scores && e.scores.COM != null);
      if (withCom.length === 0) return 2.5;
      return withCom.reduce((sum, e) => sum + parseFloat(e.scores.COM), 0) / withCom.length;
    });
    const avgCom = comAverages.reduce((a, b) => a + b, 0) / comAverages.length;
    const comVariance = comAverages.reduce((sum, c) => sum + Math.pow(c - avgCom, 2), 0) / comAverages.length;
    const scoresCOM = Math.max(0, Math.round(100 * (1 - comVariance / 0.5)));

    // -- LV2 distribution (0-100) --
    const lv2Sets = {};
    classNames.forEach(cn => {
      classes[cn].forEach(e => {
        const lv2 = (e.lv2 || '').toUpperCase().trim();
        if (lv2) {
          if (!lv2Sets[lv2]) lv2Sets[lv2] = {};
          lv2Sets[lv2][cn] = (lv2Sets[lv2][cn] || 0) + 1;
        }
      });
    });
    let lv2Score = 100;
    const lv2Names = Object.keys(lv2Sets);
    if (lv2Names.length > 0) {
      let totalDeviation = 0;
      let totalCount = 0;
      lv2Names.forEach(lv2 => {
        const counts = classNames.map(cn => lv2Sets[lv2][cn] || 0);
        const total = counts.reduce((a, b) => a + b, 0);
        if (total < 2) return;
        const ideal = total / classNames.length;
        const deviation = counts.reduce((sum, c) => sum + Math.abs(c - ideal), 0) / (total || 1);
        totalDeviation += deviation * total;
        totalCount += total;
      });
      if (totalCount > 0) {
        lv2Score = Math.max(0, Math.round(100 * (1 - totalDeviation / totalCount)));
      }
    }

    // -- Contraintes DISSO (0-100) --
    let dissoViolations = 0;
    let dissoTotal = 0;
    classNames.forEach(cn => {
      const dissoCodes = {};
      classes[cn].forEach(e => {
        const d = (e.disso || '').trim();
        if (d) {
          dissoCodes[d] = (dissoCodes[d] || 0) + 1;
          dissoTotal++;
        }
      });
      Object.values(dissoCodes).forEach(count => {
        if (count > 1) dissoViolations += (count - 1);
      });
    });
    const contraintesScore = dissoTotal > 0 ? Math.max(0, Math.round(100 * (1 - dissoViolations / dissoTotal))) : 100;

    // Score global pondere
    const score = Math.round(
      pariteScore * 0.30 +
      scoresCOM * 0.30 +
      lv2Score * 0.20 +
      contraintesScore * 0.20
    );

    return {
      score: Math.min(100, Math.max(0, score)),
      parite: Math.min(100, Math.max(0, pariteScore)),
      scores: Math.min(100, Math.max(0, scoresCOM)),
      lv2: Math.min(100, Math.max(0, lv2Score)),
      contraintes: Math.min(100, Math.max(0, contraintesScore))
    };
  }

  function getStatusClass(val) {
    if (val >= 80) return 'harm-ok';
    if (val >= 60) return 'harm-warn';
    return 'harm-bad';
  }

  function getStatusIcon(val) {
    if (val >= 80) return '\u2705';
    if (val >= 60) return '\u26A0\uFE0F';
    return '\u274C';
  }

  function getProgressClass(val) {
    if (val >= 80) return 'harmonie-excellent';
    if (val >= 60) return 'harmonie-bon';
    return 'harmonie-faible';
  }

  function updateHarmonieBar() {
    const bar = document.getElementById('harmonieBar');
    if (!bar) return;

    // Show the bar only when board has content
    const board = document.getElementById('board');
    if (!board || board.children.length === 0) {
      bar.classList.add('hidden');
      return;
    }
    bar.classList.remove('hidden');

    const h = computeHarmonieScore();

    // Score principal
    const scoreEl = document.getElementById('harmonieScore');
    const progressEl = document.getElementById('harmonieProgress');
    if (scoreEl) scoreEl.textContent = h.score + '%';
    if (progressEl) {
      progressEl.style.width = h.score + '%';
      progressEl.className = 'h-full rounded-full transition-all duration-500 ease-out ' + getProgressClass(h.score);
    }

    // Indicateurs
    const indicators = [
      { id: 'harmParite', value: h.parite, label: 'Parite' },
      { id: 'harmScores', value: h.scores, label: 'Scores' },
      { id: 'harmLV2', value: h.lv2, label: 'LV2' },
      { id: 'harmContraintes', value: h.contraintes, label: 'Contraintes' }
    ];
    indicators.forEach(ind => {
      const el = document.getElementById(ind.id);
      if (!el) return;
      const span = el.querySelector('span');
      if (span) span.textContent = getStatusIcon(ind.value);
      el.className = el.className.replace(/harm-\w+/g, '');
      el.classList.add(getStatusClass(ind.value));
    });
  }

  // Exposer globalement
  window.updateHarmonieBar = updateHarmonieBar;
  window.computeHarmonieScore = computeHarmonieScore;

  // ═══════════════════════════════════════════════════
  // R4 - MESSAGES D'ERREUR HUMANISES
  // ═══════════════════════════════════════════════════

  /**
   * Transforme un message technique de canSwap en message comprehensible.
   * @param {string} reason - La raison technique
   * @param {string} id1 - ID du premier eleve
   * @param {string} id2 - ID du deuxieme eleve
   * @returns {string} Message humanise
   */
  function humanizeSwapReason(reason, id1, id2) {
    if (!reason) return reason;

    const nom1 = (STATE.students[id1] && STATE.students[id1].nom) || 'cet eleve';
    const nom2 = (STATE.students[id2] && STATE.students[id2].nom) || 'cet eleve';

    // Conflit DISSO
    if (reason.includes('Conflit DISSO')) {
      const match = reason.match(/code (\w+)/);
      const code = match ? match[1] : '';
      // Trouver les noms des eleves du meme groupe DISSO
      const groupMembers = [];
      if (code) {
        Object.values(STATE.students).forEach(s => {
          if ((s.disso || '').trim().toUpperCase() === code.toUpperCase()) {
            groupMembers.push(s.nom);
          }
        });
      }
      if (groupMembers.length > 1) {
        return 'Impossible : ' + groupMembers.join(', ') + ' doivent etre dans des classes differentes (groupe de separation)';
      }
      return 'Impossible : ces eleves doivent etre separes dans des classes differentes';
    }

    // FIXE
    if (reason.includes('FIXE')) {
      return nom1 + ' ou ' + nom2 + ' est fixe dans sa classe par decision de la direction';
    }

    // SPEC
    if (reason.includes('SPEC')) {
      return nom1 + ' ou ' + nom2 + ' a un placement special qui ne peut pas etre modifie';
    }

    // CONDI
    if (reason.includes('CONDI')) {
      return nom1 + ' ou ' + nom2 + ' fait partie d\'un groupe qui doit rester ensemble';
    }

    // PERMUT qui doit echanger avec PERMUT
    if (reason.includes('PERMUT') && reason.includes('autre PERMUT')) {
      return nom1 + ' ne peut etre echange qu\'avec un autre eleve egalement marque a permuter';
    }

    // LV2/OPT incompatible
    if (reason.includes('interdit') || reason.includes('LV2') || reason.includes('OPT')) {
      return 'Cet echange modifierait la repartition des options ou LV2 entre les classes';
    }

    // Meme classe
    if (reason.includes('classe')) {
      return 'Les deux eleves sont deja dans la meme classe';
    }

    return reason;
  }

  window.humanizeSwapReason = humanizeSwapReason;

  // ═══════════════════════════════════════════════════
  // R5 - PREVIEW WHAT-IF
  // ═══════════════════════════════════════════════════

  let pendingSwapIds = null;

  function showSwapPreview(id1, id2) {
    const modal = document.getElementById('swapPreviewModal');
    const content = document.getElementById('swapPreviewContent');
    if (!modal || !content) {
      // Fallback: executer directement
      if (typeof performSwap === 'function') performSwap(id1, id2);
      return;
    }

    const e1 = STATE.students[id1];
    const e2 = STATE.students[id2];
    if (!e1 || !e2) return;

    const card1 = document.querySelector('.student-card[data-id="' + id1 + '"]');
    const card2 = document.querySelector('.student-card[data-id="' + id2 + '"]');
    const classe1 = card1 ? card1.closest('.droppable-zone').dataset.classe : '?';
    const classe2 = card2 ? card2.closest('.droppable-zone').dataset.classe : '?';

    pendingSwapIds = { id1, id2 };

    // Remplir les noms
    document.getElementById('previewNom1').textContent = e1.nom + (e1.prenom ? ' ' + e1.prenom : '');
    document.getElementById('previewClasse1').textContent = classe1;
    document.getElementById('previewNom2').textContent = e2.nom + (e2.prenom ? ' ' + e2.prenom : '');
    document.getElementById('previewClasse2').textContent = classe2;

    // Calculer l'impact
    const impactDiv = document.getElementById('previewImpact');
    const impacts = [];

    // Impact parite
    const zone1 = card1 ? card1.closest('.droppable-zone') : null;
    const zone2 = card2 ? card2.closest('.droppable-zone') : null;
    if (zone1 && zone2) {
      const students1 = Array.from(zone1.querySelectorAll('.student-card')).map(c => STATE.students[c.dataset.id]).filter(Boolean);
      const students2 = Array.from(zone2.querySelectorAll('.student-card')).map(c => STATE.students[c.dataset.id]).filter(Boolean);

      const f1Before = students1.filter(s => s.sexe === 'F').length;
      const m1Before = students1.filter(s => s.sexe === 'M').length;
      const f2Before = students2.filter(s => s.sexe === 'F').length;
      const m2Before = students2.filter(s => s.sexe === 'M').length;

      const f1After = f1Before + (e2.sexe === 'F' ? 1 : 0) - (e1.sexe === 'F' ? 1 : 0);
      const m1After = m1Before + (e2.sexe === 'M' ? 1 : 0) - (e1.sexe === 'M' ? 1 : 0);
      const f2After = f2Before + (e1.sexe === 'F' ? 1 : 0) - (e2.sexe === 'F' ? 1 : 0);
      const m2After = m2Before + (e1.sexe === 'M' ? 1 : 0) - (e2.sexe === 'M' ? 1 : 0);

      const diffBefore = Math.abs(f1Before - m1Before) + Math.abs(f2Before - m2Before);
      const diffAfter = Math.abs(f1After - m1After) + Math.abs(f2After - m2After);

      impacts.push({
        label: 'Parite ' + classe1,
        before: f1Before + 'F/' + m1Before + 'M',
        after: f1After + 'F/' + m1After + 'M',
        delta: diffAfter < diffBefore ? 'positive' : diffAfter > diffBefore ? 'negative' : 'neutral'
      });
      impacts.push({
        label: 'Parite ' + classe2,
        before: f2Before + 'F/' + m2Before + 'M',
        after: f2After + 'F/' + m2After + 'M',
        delta: diffAfter < diffBefore ? 'positive' : diffAfter > diffBefore ? 'negative' : 'neutral'
      });

      // Impact score COM
      const com1 = e1.scores && e1.scores.COM != null ? parseFloat(e1.scores.COM) : null;
      const com2 = e2.scores && e2.scores.COM != null ? parseFloat(e2.scores.COM) : null;
      if (com1 !== null && com2 !== null && com1 !== com2) {
        const avgCom1Before = students1.filter(s => s.scores && s.scores.COM != null)
          .reduce((sum, s) => sum + parseFloat(s.scores.COM), 0) / (students1.filter(s => s.scores && s.scores.COM != null).length || 1);
        const avgCom1After = (avgCom1Before * students1.length - com1 + com2) / students1.length;

        impacts.push({
          label: 'Moy. COM ' + classe1,
          before: avgCom1Before.toFixed(2),
          after: avgCom1After.toFixed(2),
          delta: Math.abs(avgCom1After - 2.5) < Math.abs(avgCom1Before - 2.5) ? 'positive' : 'negative'
        });
      }
    }

    // Score harmonie avant/apres
    const harmBefore = computeHarmonieScore();
    impacts.push({
      label: 'Harmonie globale',
      before: harmBefore.score + '%',
      after: '(apres confirmation)',
      delta: 'neutral'
    });

    impactDiv.innerHTML = impacts.map(imp => {
      return '<div class="impact-row impact-' + imp.delta + '">' +
        '<span>' + escapeHtml(imp.label) + '</span>' +
        '<span>' + escapeHtml(imp.before) + ' \u2192 ' + escapeHtml(imp.after) +
        (imp.delta === 'positive' ? ' \u2705' : imp.delta === 'negative' ? ' \u26A0\uFE0F' : '') +
        '</span></div>';
    }).join('');

    // Afficher
    modal.classList.remove('hidden');
    setTimeout(() => { content.style.transform = 'scale(1)'; content.style.opacity = '1'; }, 10);
  }

  function closeSwapPreview() {
    const modal = document.getElementById('swapPreviewModal');
    if (modal) modal.classList.add('hidden');
    pendingSwapIds = null;
  }

  function confirmSwapPreview() {
    if (!pendingSwapIds) return;
    const { id1, id2 } = pendingSwapIds;
    closeSwapPreview();
    if (typeof performSwap === 'function') {
      performSwap(id1, id2);
    }
  }

  window.showSwapPreview = showSwapPreview;
  window.closeSwapPreview = closeSwapPreview;
  window.confirmSwapPreview = confirmSwapPreview;

  // ═══════════════════════════════════════════════════
  // R1 - SWAP HEADER BUTTON + CONTEXTUAL BAR
  // ═══════════════════════════════════════════════════

  function initSwapHeader() {
    const btn = document.getElementById('btnSwapHeader');
    if (!btn) return;

    btn.addEventListener('click', function() {
      if (typeof window.toggleSwapMode === 'function') {
        window.toggleSwapMode();
      }
    });

    // Observer le changement d'etat swap
    const observer = new MutationObserver(updateSwapHeaderState);
    const btnSwapMain = document.getElementById('btnSwapMainMenu');
    if (btnSwapMain) {
      observer.observe(btnSwapMain, { attributes: true, attributeFilter: ['class'] });
    }
  }

  function updateSwapHeaderState() {
    const btn = document.getElementById('btnSwapHeader');
    const badge = document.getElementById('swapHeaderBadge');
    const contextBar = document.getElementById('swapContextBar');
    const isActive = typeof STATE !== 'undefined' && STATE.swapMode;

    if (btn) {
      if (isActive) {
        btn.classList.add('swap-active');
        btn.setAttribute('aria-pressed', 'true');
        document.body.classList.add('swap-mode-active');
      } else {
        btn.classList.remove('swap-active');
        btn.setAttribute('aria-pressed', 'false');
        document.body.classList.remove('swap-mode-active');
      }
    }
    if (badge) badge.textContent = isActive ? 'ON' : 'OFF';
    if (contextBar) {
      if (isActive) {
        contextBar.classList.remove('hidden');
      } else {
        contextBar.classList.add('hidden');
      }
    }
  }

  // Hook into STATE changes pour mettre a jour le header
  function patchSwapMode() {
    const origToggle = window.toggleSwapMode;
    if (!origToggle) return;

    window.toggleSwapMode = function() {
      origToggle.apply(this, arguments);
      updateSwapHeaderState();
      updateSwapInstruction();
    };
  }

  function updateSwapInstruction() {
    const instruction = document.getElementById('swapInstruction');
    if (!instruction) return;

    if (typeof STATE === 'undefined' || !STATE.swapMode) return;

    if (STATE.swapFirst) {
      const eleve = STATE.students[STATE.swapFirst];
      const nom = eleve ? eleve.nom : '?';
      instruction.textContent = nom + ' selectionne \u2192 cliquez le deuxieme eleve';
      instruction.classList.remove('animate-pulse');
    } else {
      instruction.textContent = 'Cliquez un premier eleve...';
      instruction.classList.add('animate-pulse');
    }
  }

  // ═══════════════════════════════════════════════════
  // R5 - PATCH handleCardClick pour ajouter le preview
  // ═══════════════════════════════════════════════════

  function patchHandleCardClick() {
    // On intercepte les clicks en swap mode pour ajouter le preview
    // On ne touche pas au code existant, on ajoute un listener capture
    document.addEventListener('click', function(e) {
      if (typeof STATE === 'undefined' || !STATE.swapMode) return;

      const card = e.target.closest('.student-card');
      if (!card) return;
      const eleveId = card.dataset.id;
      if (!eleveId) return;

      // Mettre a jour l'instruction contextuelle
      updateSwapInstruction();

      // Si c'est le deuxieme clic et que le swap est valide, intercepter pour le preview
      if (STATE.swapFirst && eleveId !== STATE.swapFirst) {
        const check = typeof canSwap === 'function' ? canSwap(STATE.swapFirst, eleveId) : { ok: true };

        if (check.ok) {
          // Intercepter pour afficher le preview au lieu d'executer directement
          e.stopImmediatePropagation();
          e.preventDefault();

          const firstId = STATE.swapFirst;

          // Nettoyer l'etat swap
          document.querySelectorAll('.student-card').forEach(c => c.classList.remove('swap-mode', 'swap-selected'));
          document.querySelectorAll('.droppable-zone').forEach(z => z.classList.remove('swap-target'));
          STATE.swapFirst = null;

          // Afficher le preview
          showSwapPreview(firstId, eleveId);
        } else {
          // Swap refuse : humaniser le message
          const humanMsg = humanizeSwapReason(check.reason, STATE.swapFirst, eleveId);
          if (typeof toast === 'function') toast(humanMsg, 'error');

          // Nettoyer
          document.querySelectorAll('.student-card').forEach(c => c.classList.remove('swap-mode', 'swap-selected'));
          document.querySelectorAll('.droppable-zone').forEach(z => z.classList.remove('swap-target'));
          STATE.swapFirst = null;

          e.stopImmediatePropagation();
          e.preventDefault();
        }
      } else if (!STATE.swapFirst) {
        // Premier clic - ajouter la classe visuelle amelioree
        setTimeout(() => {
          card.classList.add('swap-selected');
          updateSwapInstruction();
        }, 10);
      }
    }, true); // Capture phase pour intercepter AVANT le handler existant
  }

  // ═══════════════════════════════════════════════════
  // R6 - MODE REUNION
  // ═══════════════════════════════════════════════════

  let modeReunionActive = false;

  function toggleModeReunion() {
    modeReunionActive = !modeReunionActive;
    document.body.classList.toggle('mode-reunion', modeReunionActive);

    if (modeReunionActive) {
      // Activer le swap automatiquement
      if (typeof STATE !== 'undefined' && !STATE.swapMode && typeof window.toggleSwapMode === 'function') {
        window.toggleSwapMode();
      }
      // Activer le mode compact du header
      document.body.classList.remove('header-xl');
      // Activer le contraste eleve
      document.body.classList.add('contrast-high');
      // Afficher la jauge d'harmonie
      updateHarmonieBar();

      if (typeof toast === 'function') toast('Mode Reunion active : affichage optimise, echanges actifs', 'info');
    } else {
      // Restaurer
      document.body.classList.remove('contrast-high');
      if (typeof toast === 'function') toast('Mode Reunion desactive', 'info');
    }

    updateSwapHeaderState();
  }

  window.toggleModeReunion = toggleModeReunion;

  // ═══════════════════════════════════════════════════
  // R10 - TOOLTIPS CONTEXTUELS SUR BADGES
  // ═══════════════════════════════════════════════════

  function addBadgeTooltips() {
    // Observer les nouvelles cartes pour ajouter les tooltips
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mut) {
        mut.addedNodes.forEach(function(node) {
          if (node.nodeType !== 1) return;
          if (node.classList && node.classList.contains('student-card')) {
            attachTooltipsToCard(node);
          }
          // Aussi verifier les enfants
          if (node.querySelectorAll) {
            node.querySelectorAll('.student-card').forEach(attachTooltipsToCard);
          }
        });
      });
    });

    const board = document.getElementById('board');
    if (board) {
      observer.observe(board, { childList: true, subtree: true });
      // Traiter les cartes existantes
      board.querySelectorAll('.student-card').forEach(attachTooltipsToCard);
    }
  }

  function attachTooltipsToCard(card) {
    if (card.dataset.tooltipsAttached) return;
    card.dataset.tooltipsAttached = 'true';

    const eleveId = card.dataset.id;
    const eleve = (typeof STATE !== 'undefined' && STATE.students) ? STATE.students[eleveId] : null;
    if (!eleve) return;

    const badgeContainer = card.querySelector('.all-badges');
    if (!badgeContainer) return;

    // Trouver les badges existants et ajouter des tooltips
    badgeContainer.querySelectorAll('span, .badge').forEach(function(badge) {
      const text = (badge.textContent || '').trim().toUpperCase();
      let tooltip = '';

      // Badge DISSO
      if (text.startsWith('D') && /^D\d+$/.test(text)) {
        const code = text;
        const members = [];
        if (typeof STATE !== 'undefined' && STATE.students) {
          Object.values(STATE.students).forEach(function(s) {
            if ((s.disso || '').trim().toUpperCase() === code.substring(1)) {
              members.push(s.nom);
            }
          });
        }
        tooltip = 'Groupe de separation : ' + (members.length > 0 ? members.join(', ') : code) + '\nCes eleves doivent etre dans des classes differentes';
      }

      // Badge ASSO
      else if (text.startsWith('A') && /^A\d+$/.test(text)) {
        const code = text;
        const members = [];
        if (typeof STATE !== 'undefined' && STATE.aGroups && STATE.aGroups[code]) {
          STATE.aGroups[code].forEach(function(sid) {
            if (STATE.students[sid]) members.push(STATE.students[sid].nom);
          });
        }
        tooltip = 'Groupe lie : ' + (members.length > 0 ? members.join(', ') : code) + '\nCes eleves doivent rester dans la meme classe';
      }

      // Badge mobilite
      else if (['FIXE', 'SPEC', 'CONDI', 'PERMUT'].includes(text)) {
        const labels = {
          'FIXE': 'Fixe dans sa classe par decision de la direction',
          'SPEC': 'Placement special non modifiable',
          'CONDI': 'Conditionne par un groupe (association)',
          'PERMUT': 'A permuter : doit changer de classe'
        };
        tooltip = labels[text] || text;
      }

      // Badge LV2
      else if (['ESP', 'ALL', 'ITA', 'CHI', 'PT'].includes(text)) {
        const labels = {
          'ESP': 'Espagnol LV2',
          'ALL': 'Allemand LV2',
          'ITA': 'Italien LV2',
          'CHI': 'Chinois LV2',
          'PT': 'Portugais LV2'
        };
        tooltip = labels[text] || text + ' LV2';
      }

      if (tooltip) {
        badge.style.position = 'relative';
        badge.setAttribute('data-tooltip-text', tooltip);
        const tipEl = document.createElement('div');
        tipEl.className = 'badge-tooltip';
        tipEl.textContent = tooltip;
        badge.appendChild(tipEl);
      }
    });
  }

  // ═══════════════════════════════════════════════════
  // INITIALISATION
  // ═══════════════════════════════════════════════════

  function initUXHarmonie() {
    console.log('[UX Harmonie] Initialisation...');

    // R1 - Swap header
    initSwapHeader();

    // R1 - Cancel button
    const cancelBtn = document.getElementById('swapCancelBtn');
    if (cancelBtn) {
      cancelBtn.addEventListener('click', function() {
        if (typeof STATE !== 'undefined' && STATE.swapMode && typeof window.toggleSwapMode === 'function') {
          window.toggleSwapMode();
        }
      });
    }

    // R5 - Preview buttons
    const previewConfirm = document.getElementById('swapPreviewConfirm');
    const previewCancel = document.getElementById('swapPreviewCancel');
    const previewClose = document.getElementById('swapPreviewClose');
    if (previewConfirm) previewConfirm.addEventListener('click', confirmSwapPreview);
    if (previewCancel) previewCancel.addEventListener('click', closeSwapPreview);
    if (previewClose) previewClose.addEventListener('click', closeSwapPreview);

    // R5 - Intercepter les swaps pour afficher le preview
    patchHandleCardClick();

    // R6 - Mode Reunion
    const reunionBtn = document.getElementById('btnModeReunion');
    if (reunionBtn) reunionBtn.addEventListener('click', toggleModeReunion);

    // R10 - Tooltips
    addBadgeTooltips();

    // Patcher toggleSwapMode une fois disponible
    setTimeout(function() {
      patchSwapMode();
      updateSwapHeaderState();
    }, 500);

    // R2 - Mettre a jour la jauge apres chaque action
    // Hook sur performSwap, undo, redo, renderBoard
    hookHarmonieUpdates();

    console.log('[UX Harmonie] Module charge');
  }

  function hookHarmonieUpdates() {
    // Hook performSwap
    const origSwap = window.performSwap;
    if (origSwap) {
      window.performSwap = function() {
        origSwap.apply(this, arguments);
        setTimeout(updateHarmonieBar, 200);
        setTimeout(updateSwapHeaderState, 100);
      };
    }

    // Hook undo/redo
    ['undo', 'redo'].forEach(function(fnName) {
      const orig = window[fnName];
      if (orig) {
        window[fnName] = function() {
          orig.apply(this, arguments);
          setTimeout(updateHarmonieBar, 200);
        };
      }
    });

    // Mise a jour initiale apres chargement des donnees
    setTimeout(updateHarmonieBar, 1000);
    setTimeout(updateHarmonieBar, 3000);

    // Observer le board pour detecter les changements
    const board = document.getElementById('board');
    if (board) {
      const observer = new MutationObserver(function() {
        setTimeout(updateHarmonieBar, 300);
      });
      observer.observe(board, { childList: true, subtree: true });
    }
  }

  // Lancer l'init
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initUXHarmonie);
  } else {
    setTimeout(initUXHarmonie, 100);
  }

})();
</script>
